Ответы на вопросы по Go:

1. Какой самый эффективный способ конкатенации строк?

Самый эффективный способ конкатенации строк в Go - использование функции strings.Builder.

Пример:

package main

import (
	"fmt"
	"strings"
)

func main() {
	var sb strings.Builder
	sb.WriteString("Hello")
	sb.WriteString(", ")
	sb.WriteString("world!")

	result := sb.String()
	fmt.Println(result) // Вывод: Hello, world!
}
content_copy
Use code with caution.
Go

Почему это эффективно?

strings.Builder создает строку в памяти, изменяя ее "на месте".

Это позволяет избежать создания множества промежуточных строк, как это происходит при использовании оператора +.

Эффективность strings.Builder особенно заметна при конкатенации большого количества строк.

2. Что такое интерфейсы, как они применяются в Go?

Интерфейсы в Go определяют поведение, набор методов, которые должен иметь тип. Они позволяют писать абстрактный код, который работает с любым типом, реализующим нужный интерфейс.

Пример:

type Animal interface {
	Speak() string
}

type Dog struct {}
func (d Dog) Speak() string { return "Woof!" }

type Cat struct {}
func (c Cat) Speak() string { return "Meow!" }

func AnimalSound(a Animal) {
	fmt.Println(a.Speak())
}

func main() {
	var animal Animal
	animal = Dog{}
	AnimalSound(animal) // Вывод: Woof!

	animal = Cat{}
	AnimalSound(animal) // Вывод: Meow!
}
content_copy
Use code with caution.
Go

Применение:

Полиморфизм: Работа с разными типами данных через единый интерфейс.

Тестирование: Легко создавать заглушки (mocks) для тестирования, реализуя интерфейсы.

Расширяемость: Добавление новых типов, реализующих интерфейс, не требует изменения существующего кода.

3. Чем отличаются RWMutex от Mutex?

И Mutex, и RWMutex используются для синхронизации доступа к общим ресурсам в конкурентном коде Go.

Mutex (sync.Mutex): Обеспечивает эксклюзивный доступ к ресурсу. В любой момент времени только один goroutine может удерживать блокировку Mutex.

RWMutex (sync.RWMutex): Позволяет разделять доступ на чтение и запись:

Блокировка чтения (RLock): Множество goroutines могут одновременно удерживать блокировку чтения.

Блокировка записи (Lock): Только один goroutine может удерживать блокировку записи. Блокировка записи также блокирует доступ для чтения.

Когда использовать:

Mutex: Когда необходим строгий эксклюзивный доступ к ресурсу.

RWMutex: Когда доступ на чтение ресурса происходит чаще, чем на запись. Это позволяет увеличить производительность, разрешая параллельный доступ на чтение.

4. Чем отличаются буферизированные и не буферизированные каналы?

Не буферизированный канал:

Передача данных происходит синхронно.

Отправитель блокируется до тех пор, пока получатель не будет готов принять данные.

Размер канала равен 0.

Буферизированный канал:

Имеет буфер фиксированного размера.

Отправитель блокируется только тогда, когда буфер полон.

Получатель блокируется только тогда, когда буфер пуст.

Пример:

// Не буферизированный канал
unbuffered := make(chan int)

// Буферизированный канал (размер 3)
buffered := make(chan int, 3)
content_copy
Use code with caution.
Go

5. Какой размер у структуры struct{}{}?

Размер структуры struct{}{} равен 0 байт. Это пустая структура, которая не содержит полей, поэтому не занимает памяти.

6. Есть ли в Go перегрузка методов или операторов?

Нет, в Go нет перегрузки методов или операторов. Каждое имя функции/метода должно быть уникальным в рамках одной области видимости.

7. В какой последовательности будут выведены элементы map[int]int?

Порядок итерации по элементам map в Go не гарантируется. Map - это неупорядоченная структура данных. При каждом запуске программы порядок вывода элементов может быть разным.

8. В чем разница make и new?

new(T): Создает новый объект типа T, инициализирует его нулевым значением и возвращает указатель на него (*T).

make(T, args...): Используется для создания срезов ([]T), map (map[K]V) и каналов (chan T). make выделяет память для объекта и инициализирует его, возвращая сам объект (не указатель).

9. Сколько существует способов задать переменную типа slice или map?

Существует несколько способов задать переменную типа slice или map:

Slice:

Литерал среза:

mySlice := []int{1, 2, 3}
content_copy
Use code with caution.
Go

make():

mySlice := make([]int, 5) // Создает срез размером 5
content_copy
Use code with caution.
Go

Срез от существующего среза:

anotherSlice := mySlice[1:3]
content_copy
Use code with caution.
Go

Map:

Литерал map:

myMap := map[string]int{"one": 1, "two": 2}
content_copy
Use code with caution.
Go

make():

myMap := make(map[string]int)
content_copy
Use code with caution.
Go

10. Что выведет данная программа и почему?

func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p) // Вывод: 1
  update(p)
  fmt.Println(*p) // Вывод: 1
}
content_copy
Use code with caution.
Go

Вывод:

1
1
content_copy
Use code with caution.

Почему: Функция update получает копию указателя p. Внутри функции p начинает указывать на локальную переменную b, но это изменение не влияет на исходный указатель p в функции main.

11. Что выведет данная программа и почему?

func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
content_copy
Use code with caution.
Go

Вывод:

Поведение этой программы не определено.

Почему:

Вы создаете горутины внутри цикла, передавая им значение i по значению.

К моменту, когда горутина начнет выполняться, значение i в основной горутине может измениться (из-за цикла).

Горутины могут "увидеть" уже измененное значение i.

Возможны ситуации, когда wg.Done() будет вызван раньше, чем wg.Add(1), что приведет к панике.

12. Что выведет данная программа и почему?

func main() {
  n := 0
  if true {
     n := 1 // Новая переменная n в области видимости блока if
     n++
  }
  fmt.Println(n) // Вывод: 0
}
content_copy
Use code with caution.
Go

Вывод:

0
content_copy
Use code with caution.

Почему: Внутри блока if создается новая переменная n с областью видимости ограниченной этим блоком. Изменение этой локальной n никак не затрагивает переменную n, объявленную вне блока if.

13. Что выведет данная программа и почему?

func someAction(v []int8, b int8) {
  v[0] = 100 
  v = append(v, b) // v теперь указывает на новый срез
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6) 
  fmt.Println(a) // Вывод: [100 2 3 4 5]
}
content_copy
Use code with caution.
Go

Вывод:

[100 2 3 4 5]
content_copy
Use code with caution.

Почему:

Функция someAction получает срез v по значению (как копию).

Изменение v[0] внутри функции влияет на базовый массив, на который указывает срез.

v = append(v, b) - создает новый срез v внутри функции. Изменения этого нового среза не видны вне функции.

14. Что выведет данная программа и почему?

func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a") 
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice) // Вывод: [b b a]
  }(slice)
  
  fmt.Print(slice) // Вывод: [a a]
}
content_copy
Use code with caution.
Go

Вывод:

[b b a][a a]
content_copy
Use code with caution.

Почему:

Анонимная функция получает срез slice по значению.

Внутри функции создается копия среза. Все изменения (append, slice[0] = "b") влияют только на эту копию.

Исходный срез slice в функции main остается неизменным.

Надеюсь, эти ответы были полезны!