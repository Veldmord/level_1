package main

//Реализовать постоянную запись данных в канал (главный поток).
//Реализовать набор из N воркеров, которые читают произвольные данные из канала и выводят в stdout.
//Необходима возможность выбора количества воркеров при старте.
//Программа должна завершаться по нажатию Ctrl+C. Выбрать и обосновать способ завершения работы всех воркеров.

//Обоснование способа завершения:
// был выбран путь с использованием

import (
	"fmt"
	"os"
	"os/signal"
	"sync"
)

func worker(id int, dataChannel <-chan string, wg *sync.WaitGroup, stop <-chan struct{}) {
	defer wg.Done()                        //уменьшаем счетчик горутин
	fmt.Printf("Воркер %d: запущен\n", id) //Воркер 1: запущен
	for {                                  //бесконечная функция
		select {
		case msg, ok := <-dataChannel: //забираем из канала данные
			if ok { //проверяем есть ли  что то в канале
				fmt.Printf("Воркер %d: %s\n", id, msg) //Воркер 1: Данные 1
			}
		case <-stop: //обрабатываем сигнал об остановке
			fmt.Printf("Воркер %d: остановлен\n", id) //Воркер 1: остановлен
			return
		}
	}
}

func main() {
	var numWorkers int //переменная для записи количества воркеров
	fmt.Print("Введите количество воркеров: ")
	fmt.Scanln(&numWorkers) //вводим количество воркеров через консоль

	dataChannel := make(chan string) //создаем канал для отправки сообщений
	stop := make(chan struct{})      // создаем каал для отправки сообщения о завершении

	var wg sync.WaitGroup //создаем ВГ для синхронизации горутин

	for i := 1; i <= numWorkers; i++ { //запускаем воркеры
		wg.Add(1)                            //+1 к количеству воркеров
		go worker(i, dataChannel, &wg, stop) //запускаем воркер и передаем туда (ID воркера, данные, ссылку на количество воркеров, стоп слово)
	}

	signalChan := make(chan os.Signal, 1)   // создаем канал для перердачи данных типа os.Signal, это тип представляющий сигналы операционной системы
	signal.Notify(signalChan, os.Interrupt) //регистрируем и отправляем в канал сигнал ОС

	go func() { //создаем горутины для отправки в канал сообщений
		i := 1 //счетчик сообщений
		for {  //бесконечный цикл
			select { //создаем кейсы
			case <-signalChan: //обрабатываем сообщение об остановки
				fmt.Println("Завершение программы...")
				close(dataChannel) //закрываем канал dataChannel
				close(stop)        //закрываем канал stop
				return             //выходим из for
			default:
				dataChannel <- fmt.Sprintf("Данные %d", i) //отправляем данные в канал dataChannel
				i++                                        //+1
			}
		}
	}()

	wg.Wait()                             //вежливо ждем завершения горутин
	fmt.Println("Все воркеры завершены.") // кайф
}
